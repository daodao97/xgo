import{e as $,g as B,a as L,b as K,c as N,d as Q,f as U,h as Y,i as I,j as W,k as X,r as _,l as Z,m as q,n as z}from"./floating-ui-utils-BQsPTHQk.js";function H(o,s,m){let{reference:n,floating:r}=o;const t=L(s),a=W(s),l=q(a),g=B(s),x=t==="y",d=n.x+n.width/2-r.width/2,i=n.y+n.height/2-r.height/2,f=n[l]/2-r[l]/2;let e;switch(g){case"top":e={x:d,y:n.y-r.height};break;case"bottom":e={x:d,y:n.y+n.height};break;case"right":e={x:n.x+n.width,y:i};break;case"left":e={x:n.x-r.width,y:i};break;default:e={x:n.x,y:n.y}}switch(X(s)){case"start":e[a]-=f*(m&&x?-1:1);break;case"end":e[a]+=f*(m&&x?-1:1);break}return e}const ie=async(o,s,m)=>{const{placement:n="bottom",strategy:r="absolute",middleware:t=[],platform:a}=m,l=t.filter(Boolean),g=await(a.isRTL==null?void 0:a.isRTL(s));let x=await a.getElementRects({reference:o,floating:s,strategy:r}),{x:d,y:i}=H(x,n,g),f=n,e={},c=0;for(let w=0;w<l.length;w++){const{name:u,fn:v}=l[w],{x:p,y:h,data:b,reset:y}=await v({x:d,y:i,initialPlacement:n,placement:f,strategy:r,middlewareData:e,rects:x,platform:a,elements:{reference:o,floating:s}});d=p??d,i=h??i,e={...e,[u]:{...e[u],...b}},y&&c<=50&&(c++,typeof y=="object"&&(y.placement&&(f=y.placement),y.rects&&(x=y.rects===!0?await a.getElementRects({reference:o,floating:s,strategy:r}):y.rects),{x:d,y:i}=H(x,f,g)),w=-1)}return{x:d,y:i,placement:f,strategy:r,middlewareData:e}};async function G(o,s){var m;s===void 0&&(s={});const{x:n,y:r,platform:t,rects:a,elements:l,strategy:g}=o,{boundary:x="clippingAncestors",rootBoundary:d="viewport",elementContext:i="floating",altBoundary:f=!1,padding:e=0}=$(s,o),c=I(e),u=l[f?i==="floating"?"reference":"floating":i],v=_(await t.getClippingRect({element:(m=await(t.isElement==null?void 0:t.isElement(u)))==null||m?u:u.contextElement||await(t.getDocumentElement==null?void 0:t.getDocumentElement(l.floating)),boundary:x,rootBoundary:d,strategy:g})),p=i==="floating"?{x:n,y:r,width:a.floating.width,height:a.floating.height}:a.reference,h=await(t.getOffsetParent==null?void 0:t.getOffsetParent(l.floating)),b=await(t.isElement==null?void 0:t.isElement(h))?await(t.getScale==null?void 0:t.getScale(h))||{x:1,y:1}:{x:1,y:1},y=_(t.convertOffsetParentRelativeRectToViewportRelativeRect?await t.convertOffsetParentRelativeRectToViewportRelativeRect({elements:l,rect:p,offsetParent:h,strategy:g}):p);return{top:(v.top-y.top+c.top)/b.y,bottom:(y.bottom-v.bottom+c.bottom)/b.y,left:(v.left-y.left+c.left)/b.x,right:(y.right-v.right+c.right)/b.x}}const se=o=>({name:"arrow",options:o,async fn(s){const{x:m,y:n,placement:r,rects:t,platform:a,elements:l,middlewareData:g}=s,{element:x,padding:d=0}=$(o,s)||{};if(x==null)return{};const i=I(d),f={x:m,y:n},e=W(r),c=q(e),w=await a.getDimensions(x),u=e==="y",v=u?"top":"left",p=u?"bottom":"right",h=u?"clientHeight":"clientWidth",b=t.reference[c]+t.reference[e]-f[e]-t.floating[c],y=f[e]-t.reference[e],V=await(a.getOffsetParent==null?void 0:a.getOffsetParent(x));let S=V?V[h]:0;(!S||!await(a.isElement==null?void 0:a.isElement(V)))&&(S=l.floating[h]||t.floating[c]);const j=b/2-y/2,D=S/2-w[c]/2-1,R=z(i[v],D),F=z(i[p],D),E=R,M=S-w[c]-F,A=S/2-w[c]/2+j,T=Y(E,A,M),k=!g.arrow&&X(r)!=null&&A!==T&&t.reference[c]/2-(A<E?R:F)-w[c]/2<0,P=k?A<E?A-E:A-M:0;return{[e]:f[e]+P,data:{[e]:T,centerOffset:A-T-P,...k&&{alignmentOffset:P}},reset:k}}}),oe=function(o){return o===void 0&&(o={}),{name:"flip",options:o,async fn(s){var m,n;const{placement:r,middlewareData:t,rects:a,initialPlacement:l,platform:g,elements:x}=s,{mainAxis:d=!0,crossAxis:i=!0,fallbackPlacements:f,fallbackStrategy:e="bestFit",fallbackAxisSideDirection:c="none",flipAlignment:w=!0,...u}=$(o,s);if((m=t.arrow)!=null&&m.alignmentOffset)return{};const v=B(r),p=L(l),h=B(l)===l,b=await(g.isRTL==null?void 0:g.isRTL(x.floating)),y=f||(h||!w?[K(l)]:N(l)),V=c!=="none";!f&&V&&y.push(...Q(l,w,c,b));const S=[l,...y],j=await G(s,u),D=[];let R=((n=t.flip)==null?void 0:n.overflows)||[];if(d&&D.push(j[v]),i){const A=U(r,a,b);D.push(j[A[0]],j[A[1]])}if(R=[...R,{placement:r,overflows:D}],!D.every(A=>A<=0)){var F,E;const A=(((F=t.flip)==null?void 0:F.index)||0)+1,T=S[A];if(T&&(!(i==="alignment"?p!==L(T):!1)||R.every(O=>L(O.placement)===p?O.overflows[0]>0:!0)))return{data:{index:A,overflows:R},reset:{placement:T}};let k=(E=R.filter(P=>P.overflows[0]<=0).sort((P,O)=>P.overflows[1]-O.overflows[1])[0])==null?void 0:E.placement;if(!k)switch(e){case"bestFit":{var M;const P=(M=R.filter(O=>{if(V){const C=L(O.placement);return C===p||C==="y"}return!0}).map(O=>[O.placement,O.overflows.filter(C=>C>0).reduce((C,J)=>C+J,0)]).sort((O,C)=>O[1]-C[1])[0])==null?void 0:M[0];P&&(k=P);break}case"initialPlacement":k=l;break}if(r!==k)return{reset:{placement:k}}}return{}}}},ee=new Set(["left","top"]);async function te(o,s){const{placement:m,platform:n,elements:r}=o,t=await(n.isRTL==null?void 0:n.isRTL(r.floating)),a=B(m),l=X(m),g=L(m)==="y",x=ee.has(a)?-1:1,d=t&&g?-1:1,i=$(s,o);let{mainAxis:f,crossAxis:e,alignmentAxis:c}=typeof i=="number"?{mainAxis:i,crossAxis:0,alignmentAxis:null}:{mainAxis:i.mainAxis||0,crossAxis:i.crossAxis||0,alignmentAxis:i.alignmentAxis};return l&&typeof c=="number"&&(e=l==="end"?c*-1:c),g?{x:e*d,y:f*x}:{x:f*x,y:e*d}}const ae=function(o){return o===void 0&&(o=0),{name:"offset",options:o,async fn(s){var m,n;const{x:r,y:t,placement:a,middlewareData:l}=s,g=await te(s,o);return a===((m=l.offset)==null?void 0:m.placement)&&(n=l.arrow)!=null&&n.alignmentOffset?{}:{x:r+g.x,y:t+g.y,data:{...g,placement:a}}}}},le=function(o){return o===void 0&&(o={}),{name:"shift",options:o,async fn(s){const{x:m,y:n,placement:r}=s,{mainAxis:t=!0,crossAxis:a=!1,limiter:l={fn:u=>{let{x:v,y:p}=u;return{x:v,y:p}}},...g}=$(o,s),x={x:m,y:n},d=await G(s,g),i=L(B(r)),f=Z(i);let e=x[f],c=x[i];if(t){const u=f==="y"?"top":"left",v=f==="y"?"bottom":"right",p=e+d[u],h=e-d[v];e=Y(p,e,h)}if(a){const u=i==="y"?"top":"left",v=i==="y"?"bottom":"right",p=c+d[u],h=c-d[v];c=Y(p,c,h)}const w=l.fn({...s,[f]:e,[i]:c});return{...w,data:{x:w.x-m,y:w.y-n,enabled:{[f]:t,[i]:a}}}}}};export{se as a,ie as c,G as d,oe as f,ae as o,le as s};
